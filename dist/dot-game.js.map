{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./server/src/entities/game-message.ts","webpack:///./server/src/entities/point.ts","webpack:///./server/src/dot-game.log.ts","webpack:///./server/src/entities/line-segment.ts","webpack:///./server/src/validators/line.type.ts","webpack:///./server/src/geometry/geometry.ts","webpack:///./server/src/validators/new-line.validator.ts","webpack:///./server/src/main.ts","webpack:///./server/src/dot.game.ts","webpack:///./server/src/dot-game.engine.ts","webpack:///./server/src/entities/game-message.type.ts","webpack:///./server/src/entities/line-output.ts","webpack:///./server/src/geometry/line-walker.ts","webpack:///./server/src/exceptions/invalid-line-type.exception.ts","webpack:///./server/src/exceptions/parallel-lines.exception.ts","webpack:///./server/src/entities/player.ts","webpack:///./server/src/game-states/game-over.state.ts","webpack:///./server/src/game-states/line-end.state.ts","webpack:///./server/src/validators/octilinear-line.validator.ts","webpack:///./server/src/validators/visited-node.validator.ts","webpack:///./server/src/game-states/line-start.state.ts","webpack:///./server/src/path-tracker.ts","webpack:///./server/src/exceptions/no-endpoints.exception.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Construct","messageType","heading","message","line","GameMessage","LineOutput","Initialize","GameMessageType","ValidStartNode","InvalidStartNode","ValidEndNode","newLine","InvalidEndNode","GameOver","UpdateText","msg","this","body","is","point","x","y","toString","Point","setLogger","logger","DotGameLog","log","optionalParams","info","error","warn","debug","console","_startPoint","_endPoint","points","pointResult","iterator","LineWalker","walkTheLine","next","done","push","asFlipped","LineSegment","endPoint","startPoint","LineType","isBetween","check","start","end","temp","isPointOnLineSegment","checkPoint","isWithinXBounds","Geometry","isWithinYBounds","areLinesParallel","line1","line2","findIntersectionOfLines","e","ParallelLinesException","doLineSegmentsTouch","intersectionPoint","intersectsOnLine1","intersectsOnLine2","s1","e1","s2","e2","a1","b1","c1","a2","b2","c2","delta","lineType","Invalid","diffX","Math","abs","diffY","Vertical","Horizontal","Diagonal","isValid","octilinearLineValidator","path","hasEndPoints","isEndPoint","visitedNodeValidator","isNewLineValid","totalTouchingLines","lines","checkLine","OctilinearLineValidator","VisitedNodeValidator","NewLineValidator","dotGame","DotGame","app","ports","response","send","request","subscribe","messageJSON","game","boardWidth","boardHeight","out","DotGameEngine","initGame","_path","state","constructor","_gameState","changePlayersTurn","_currentPlayerNumber","players","length","timeoutMessage","clearTimoutMessage","_timeoutMessage","setTimeout","timeout","clearTimeout","lineStartState","PathTracker","playerName","currentPlayer","isPointOnBoard","waitingPlayer","isMoveAvailable","endPoints","headPoint","tailPoint","lineValidator","adjacentPoints","getAdjacentPoints","adjacentPoint","JSON","parse","selectPoint","Player","LineStartState","nextLineEndState","LineEndState","gameOverState","GameOverState","doWalkHorizontal","doWalkVertical","walkDiagonal","InvalidLineTypeException","pointA","pointB","leftX","rightX","xDirection","yDirection","distanceToTravel","yAxis","beginX","endX","diff","direction","xAxis","beginY","endY","Error","setPrototypeOf","startLinePoint","currentPlayerName","gameState","addLine","nextPlayerName","linePoints","linePoint","visitedPoints","_visitedPoints","_lines","flippedLine","unshift","forEach","NoEndpointsException","build","coordinates"],"mappings":"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","file":"dot-game.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","import { GameMessageType } from './game-message.type';\nimport { LineOutput } from './line-output';\nimport { LineSegment } from './line-segment';\n\n/**\n * Game Message response\n */\nexport class GameMessage {\n  public readonly body: { newLine: null | LineOutput; heading: string; message: string };\n\n  private constructor(\n    public msg: string,\n    heading: string = '',\n    message: string = '',\n    newLine: LineOutput | null = null\n  ) {\n    this.msg = msg;\n    this.body = { newLine, heading, message };\n  }\n\n  /**\n   *\n   * @param messageType\n   * @param heading\n   * @param message\n   * @param line\n   * @constructor\n   */\n  private static Construct(\n    messageType: string,\n    heading: string,\n    message: string,\n    line?: LineSegment\n  ): GameMessage {\n    const newLine = line ? new LineOutput(line) : null;\n    return new GameMessage(messageType, heading, message, newLine);\n  }\n\n  /////////////////////////////////////////////////////\n  // Static methods to safely construct a game messages\n  /////////////////////////////////////////////////////\n\n  /**\n   * Create in an INITIALIZE game message\n   *\n   * @param heading\n   * @param message\n   */\n  static Initialize(heading: string, message: string) {\n    return GameMessage.Construct(GameMessageType.Initialize, heading, message);\n  }\n\n  /**\n   * Create in a VALID_START_NODE game message\n   *\n   * @param heading\n   * @param message\n   */\n  static ValidStartNode(heading: string, message: string) {\n    return GameMessage.Construct(GameMessageType.ValidStartNode, heading, message);\n  }\n\n  /**\n   * Create in an INVALID_START_NODE game message\n   *\n   * @param heading\n   * @param message\n   */\n  static InvalidStartNode(\n    heading: string,\n    message: string = 'You must start on either end of the path!'\n  ) {\n    return GameMessage.Construct(GameMessageType.InvalidStartNode, heading, message);\n  }\n\n  /**\n   * Create in a VALID_END_NODE game message\n   *\n   * @param heading\n   * @param message\n   * @param newLine\n   */\n  static ValidEndNode(heading: string, message: string, newLine: LineSegment): GameMessage {\n    return GameMessage.Construct(GameMessageType.ValidEndNode, heading, message, newLine);\n  }\n\n  /**\n   * Create in an INVALID_END_NODE game message\n   *\n   * @param heading\n   * @param message\n   */\n  static InvalidEndNode(heading: string, message: string = 'Not a valid line.') {\n    return GameMessage.Construct(GameMessageType.InvalidEndNode, heading, message);\n  }\n\n  /**\n   * Create in a GAME_OVER game message\n   *\n   * @param heading\n   * @param message\n   * @param newLine\n   */\n  static GameOver(heading: string, message: string, newLine: LineSegment): GameMessage {\n    return GameMessage.Construct(GameMessageType.GameOver, heading, message, newLine);\n  }\n\n  /**\n   * Create in a GAME_OVER game message\n   *\n   * @param heading\n   * @param message\n   */\n  static UpdateText(heading: string, message: string): GameMessage {\n    return GameMessage.Construct(GameMessageType.UpdateText, heading, message);\n  }\n}\n","export class Point {\n  constructor(public readonly x: number, public readonly y: number) {}\n\n  /**\n   * Check whether a given point is the same point;\n   *\n   * @param point\n   */\n  is(point: Point) {\n    return this.x === point.x && this.y === point.y;\n  }\n\n  get name() {\n    return `(${this.x},${this.y})`;\n  }\n\n  toString() {\n    return 'Point' + this.name;\n  }\n}\n","export interface DotGameLogInterface {\n  log(message: any, ...optionalParams: any[]): void;\n  info(message: any, ...optionalParams: any[]): void;\n  error(message: any, ...optionalParams: any[]): void;\n  warn(message: any, ...optionalParams: any[]): void;\n  debug(message: any, ...optionalParams: any[]): void;\n}\n\n/**\n * DotGame Logger\n */\nexport class DotGameLog {\n  private static logger: DotGameLogInterface = console;\n\n  static setLogger(logger: any) {\n    DotGameLog.logger = logger;\n  }\n\n  static log(message: any, ...optionalParams: any[]) {\n    DotGameLog.logger.log(message, ...optionalParams);\n  }\n\n  static info(message: any, ...optionalParams: any[]) {\n    DotGameLog.logger.info(message, ...optionalParams);\n  }\n\n  static error(message: any, ...optionalParams: any[]) {\n    DotGameLog.logger.error(message, ...optionalParams);\n  }\n\n  static warn(message: any, ...optionalParams: any[]) {\n    DotGameLog.logger.warn(message, ...optionalParams);\n  }\n\n  static debug(message: any, ...optionalParams: any[]) {\n    DotGameLog.logger.debug(message, ...optionalParams);\n  }\n}\n","import { LineWalker } from '../geometry/line-walker';\nimport { Point } from './point';\n\nexport class LineSegment {\n  private readonly _startPoint: Point;\n  get startPoint() {\n    return this._startPoint;\n  }\n\n  private readonly _endPoint: Point;\n\n  get endPoint() {\n    return this._endPoint;\n  }\n\n  constructor(startPoint: Point, endPoint: Point) {\n    this._endPoint = endPoint;\n    this._startPoint = startPoint;\n  }\n\n  // Accessors\n\n  get name() {\n    return `${this._startPoint.name}-${this._endPoint.name},`;\n  }\n\n  toString() {\n    return 'Line of ' + this.name;\n  }\n\n  /**\n   * Get the points that this line visits\n   */\n  points() {\n    const points: Point[] = [];\n    const iterator = LineWalker.walkTheLine(this);\n    let pointResult: IteratorResult<Point>;\n\n    while (true) {\n      pointResult = iterator.next();\n      if (pointResult.done) {\n        break;\n      }\n      points.push(pointResult.value);\n    }\n    return points;\n  }\n\n  /**\n   * Get a new reversed line by swapping the endpoints\n   */\n  asFlipped() {\n    return new LineSegment(this.endPoint, this.startPoint);\n  }\n}\n","export enum LineType {\n  Horizontal,\n  Vertical,\n  Diagonal,\n  Invalid,\n}\n","import { LineSegment } from '../entities/line-segment';\nimport { Point } from '../entities/point';\nimport { ParallelLinesException } from '../exceptions/parallel-lines.exception';\nimport { LineType } from '../validators/line.type';\n\nexport class Geometry {\n  /**\n   * Determine if a value is between (inclusive) of two other values\n   *\n   * @param check\n   * @param start\n   * @param end\n   */\n  private static isBetween(check: number, start: number, end: number): boolean {\n    if (start > end) {\n      const temp = start;\n      start = end;\n      end = temp;\n    }\n    return start <= check && check <= end;\n  }\n\n  /**\n   * Check if a Point is on a Line Segment\n   *\n   * @param checkPoint\n   * @param line\n   */\n  static isPointOnLineSegment(checkPoint: Point, line: LineSegment): boolean {\n    const startPoint: Point = line.startPoint;\n    const endPoint: Point = line.endPoint;\n\n    if (checkPoint.is(startPoint) || checkPoint.is(endPoint)) {\n      return true;\n    }\n\n    const slopeOfStartCheck = (startPoint.x - checkPoint.x) / (startPoint.y - checkPoint.y);\n    const slopeOfCheckEnd = (checkPoint.x - endPoint.x) / (checkPoint.y - endPoint.y);\n\n    // If the slopes are different then the Check point is not on the infinite line\n    const isSameSlope = slopeOfStartCheck === slopeOfCheckEnd;\n    if (!isSameSlope) {\n      return false;\n    }\n\n    const isWithinXBounds = Geometry.isBetween(checkPoint.x, startPoint.x, endPoint.x);\n    const isWithinYBounds = Geometry.isBetween(checkPoint.y, startPoint.y, endPoint.y);\n    return isWithinXBounds && isWithinYBounds;\n  }\n\n  /**\n   * Checks if two line segments are parallel\n   *\n   * @param line1\n   * @param line2\n   */\n  static areLinesParallel(line1: LineSegment, line2: LineSegment) {\n    try {\n      // Throws ParallelLinesException is the lines are parallel\n      Geometry.findIntersectionOfLines(line1, line2);\n      return false;\n    } catch (e) {\n      if (e instanceof ParallelLinesException) {\n        // lines are parallel\n        return true;\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * Check whether two line segments touch with each other\n   *\n   * @param line1\n   * @param line2\n   */\n  static doLineSegmentsTouch(line1: LineSegment, line2: LineSegment): boolean {\n    try {\n      // If any endpoint is on the other line than they touch.\n      if (\n        Geometry.isPointOnLineSegment(line1.startPoint, line2) ||\n        Geometry.isPointOnLineSegment(line1.endPoint, line2) ||\n        Geometry.isPointOnLineSegment(line2.startPoint, line1) ||\n        Geometry.isPointOnLineSegment(line2.endPoint, line1)\n      ) {\n        return true;\n      }\n\n      const intersectionPoint = Geometry.findIntersectionOfLines(line1, line2);\n      const intersectsOnLine1 = Geometry.isPointOnLineSegment(intersectionPoint, line1);\n      const intersectsOnLine2 = Geometry.isPointOnLineSegment(intersectionPoint, line2);\n      return intersectsOnLine1 && intersectsOnLine2;\n    } catch (e) {\n      if (e instanceof ParallelLinesException) {\n        // lines are parallel\n        return false;\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * Find the intersection of two Line segments as if they were infinite lines\n   *\n   * Courtesy of https://rosettacode.org/wiki/Find_the_intersection_of_two_lines#C.23\n   *\n   * @param line1\n   * @param line2\n   * @throws ParallelLinesException\n   */\n  static findIntersectionOfLines(line1: LineSegment, line2: LineSegment): Point {\n    // Starting point of first line\n    const s1 = line1.startPoint;\n    // Ending point of first line\n    const e1 = line1.endPoint;\n    // Starting point of second line\n    const s2 = line2.startPoint;\n    // Ending point of second line\n    const e2 = line2.endPoint;\n\n    const a1 = e1.y - s1.y;\n    const b1 = s1.x - e1.x;\n    const c1 = a1 * s1.x + b1 * s1.y;\n\n    const a2 = e2.y - s2.y;\n    const b2 = s2.x - e2.x;\n    const c2 = a2 * s2.x + b2 * s2.y;\n\n    const delta = a1 * b2 - a2 * b1;\n    // When delta is 0 the lines are parallel.\n    if (delta === 0) {\n      throw new ParallelLinesException('Lines do not intersect!');\n    } else {\n      return new Point((b2 * c1 - b1 * c2) / delta, (a1 * c2 - a2 * c1) / delta);\n    }\n  }\n\n  /**\n   * Determines if the line segment is horizontal, vertical or diagonal (45-degrees)\n   *\n   * @param line\n   */\n  static lineType(line: LineSegment): LineType {\n    const startPoint = line.startPoint;\n    const endPoint = line.endPoint;\n\n    if (startPoint.x === endPoint.x && startPoint.y === endPoint.y) {\n      return LineType.Invalid;\n    }\n\n    const diffX = Math.abs(startPoint.x - endPoint.x);\n    const diffY = Math.abs(startPoint.y - endPoint.y);\n\n    // Is Vertical line\n    const isVerticalLine = diffX === 0 && diffY !== 0;\n    if (isVerticalLine) {\n      return LineType.Vertical;\n    }\n\n    // Horizontal line\n    const isHorizontalLine = diffY === 0 && diffX !== 0;\n    if (isHorizontalLine) {\n      return LineType.Horizontal;\n    }\n\n    // Diagonal line @ 45-degrees\n    const isDiagonal = diffX === diffY;\n    if (isDiagonal) {\n      return LineType.Diagonal;\n    }\n\n    // If it's not horizontal, vertical or at a 45-degree angle, it's invalid for this game.\n    return LineType.Invalid;\n  }\n}\n","import { DotGameLog } from '../dot-game.log';\nimport { LineSegment } from '../entities/line-segment';\nimport { Geometry } from '../geometry/geometry';\nimport { PathTracker } from '../path-tracker';\nimport { OctilinearLineValidator } from './octilinear-line.validator';\nimport { VisitedNodeValidator } from './visited-node.validator';\n\n/**\n * Validates if a new line is a valid line\n *\n * A new line:\n * - Must be an Octilinear line\n * - AND If a path exists:\n *    - Must start at the head or tail of the path (i.e. endpoints of the path)\n *    - AND Cannot visit another visited node (other than it's starting point)\n *    - AND May not touch another line touch other than the line it was continued from\n *           - can't intersect (i.e.: can't touch more than one line)\n */\nexport class NewLineValidator {\n  private readonly octilinearLineValidator: OctilinearLineValidator;\n  private readonly visitedNodeValidator: VisitedNodeValidator;\n\n  constructor(private readonly path: PathTracker) {\n    this.octilinearLineValidator = new OctilinearLineValidator();\n    this.visitedNodeValidator = new VisitedNodeValidator(path);\n  }\n\n  isValid(line: LineSegment) {\n    // - Must be an Octilinear line\n    if (!this.octilinearLineValidator.isValid(line)) {\n      return false;\n    }\n\n    // - If a path exists\n    if (this.path.hasEndPoints()) {\n      // - Must start at the head or tail of the path\n      if (!this.path.isEndPoint(line.startPoint)) {\n        return false;\n      }\n\n      // - May not touch another line touch\n\n      if (!this.visitedNodeValidator.isNewLineValid(line)) {\n        return false;\n      }\n\n      // It's implied that the new line is touching a point on the path by the check above\n\n      let totalTouchingLines = 0;\n      for (const checkLine of this.path.lines) {\n        if (Geometry.doLineSegmentsTouch(line, checkLine)) {\n          totalTouchingLines++;\n          // The 1 line would be the from the continuation of the path\n          if (totalTouchingLines > 1) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n}\n","import { DotGame } from './dot.game';\n// @ts-ignore app is globally defined\nconst dotGame = new DotGame(4, 4, app.ports.response.send, console);\n// @ts-ignore app is globally defined\napp.ports.request.subscribe(message => dotGame.request(message));\n","import { DotGameEngine } from './dot-game.engine';\nimport { DotGameLogInterface } from './dot-game.log';\n\n/**\n * DotGame\n *\n * Exposes a the DotGame's request handler and initializes the game engine\n */\nexport class DotGame {\n  private game: DotGameEngine;\n\n  constructor(\n    private boardWidth: number = 4,\n    private boardHeight: number = 4,\n    private out: any,\n    logger?: DotGameLogInterface\n  ) {\n    this.game = new DotGameEngine(boardWidth, boardHeight, out, logger);\n    this.game.initGame();\n  }\n\n  request(messageJSON: any) {\n    this.game.request(messageJSON);\n  }\n}\n","import { DotGameLog, DotGameLogInterface } from './dot-game.log';\nimport { GameMessage } from './entities/game-message';\nimport { LineSegment } from './entities/line-segment';\nimport { Player } from './entities/player';\nimport { Point } from './entities/point';\nimport { DotGameState } from './game-states/dot-game.state';\nimport { GameOverState } from './game-states/game-over.state';\nimport { LineEndState } from './game-states/line-end.state';\nimport { LineStartState } from './game-states/line-start.state';\nimport { PathTracker } from './path-tracker';\nimport { NewLineValidator } from './validators/new-line.validator';\n\n/**\n * The game engine\n */\nexport class DotGameEngine {\n  public readonly lineStartState: DotGameState;\n  public readonly nextLineEndState: DotGameState;\n  public readonly gameOverState: DotGameState;\n\n  /**\n   * The Players of the game\n   */\n  private players: Player[] = [];\n\n  /**\n   * Path tracker\n   */\n  private _path: PathTracker = new PathTracker();\n\n  get path() {\n    return this._path;\n  }\n\n  /**\n   * Reference to the timeout message\n   */\n  private _timeoutMessage?: number | null;\n\n  /**\n   * Holds the state of the game\n   */\n  private _gameState: DotGameState;\n\n  /**\n   * Set the game set\n   *\n   * @param state\n   */\n  set gameState(state: DotGameState) {\n    DotGameLog.debug('Game State: ' + state.constructor.name);\n    this._gameState = state;\n  }\n\n  /**\n   * The current player's index number in the players array\n   */\n  private _currentPlayerNumber = 0; // Player 1 always starts\n\n  // Keeps track of the current players starting line Point\n  public startLinePoint!: Point;\n\n  /**\n   * Create a new DotGame\n   *\n   * @param boardWidth\n   * @param boardHeight\n   * @param out\n   * @param logger\n   */\n  constructor(\n    private boardWidth: number = 4,\n    private boardHeight: number = 4,\n    private out: any,\n    logger?: DotGameLogInterface\n  ) {\n    if (!logger) {\n      DotGameLog.setLogger(console);\n    }\n\n    // Create Players\n    for (let i = 0; i < 2; i++) {\n      const playerName = 'Player ' + (i + 1); // player 0\n      this.players.push(new Player(playerName));\n    }\n\n    this.lineStartState = new LineStartState(this);\n    this.nextLineEndState = new LineEndState(this);\n    this.gameOverState = new GameOverState(this);\n    this._gameState = this.lineStartState;\n\n    DotGameLog.debug('');\n    DotGameLog.debug('-------------------');\n    DotGameLog.debug('DotGame constructed');\n    DotGameLog.debug('-------------------');\n  }\n\n  /**\n   * Change the player's turns\n   */\n  public changePlayersTurn() {\n    this._currentPlayerNumber++;\n    if (this._currentPlayerNumber === this.players.length) {\n      this._currentPlayerNumber = 0;\n    }\n  }\n\n  /**\n   * Send a message when the player takes too long to perform an action.\n   *\n   * Clears any existing timeout message prior to setting a new timeout message\n   */\n  public timeoutMessage() {\n    // Clear any timeout message that is waiting to be sent\n    this.clearTimoutMessage();\n    // Send a timeout message X secs after a node is selected\n    // @ts-ignore\n    this._timeoutMessage = setTimeout(() => {\n      this.send(this._gameState.timeout());\n    }, 5000);\n  }\n\n  /**\n   * Clear an existing timeout message if one exists\n   */\n  public clearTimoutMessage() {\n    if (this._timeoutMessage) {\n      clearTimeout(this._timeoutMessage);\n      this._timeoutMessage = null;\n    }\n  }\n\n  /**\n   * Initialize a new game by resetting the game state\n   */\n  initGame() {\n    this._gameState = this.lineStartState;\n    this._currentPlayerNumber = 0;\n    this._path = new PathTracker();\n    const playerName = this.currentPlayer().name;\n    this.timeoutMessage();\n    DotGameLog.debug('New Game Initialized');\n    this.send(GameMessage.Initialize(playerName, `Awaiting ${playerName}'s Move`));\n  }\n\n  /**\n   * Checks if a Point is on the board.\n   *\n   * @param point\n   */\n  isPointOnBoard(point: Point): boolean {\n    return point.x >= 0 && point.x < this.boardWidth && point.y >= 0 && point.y < this.boardHeight;\n  }\n\n  /**\n   * Gets the current Player\n   */\n  currentPlayer() {\n    return this.players[this._currentPlayerNumber];\n  }\n\n  /**\n   * Get the other player who is waiting for their turn\n   */\n  waitingPlayer() {\n    if (this._currentPlayerNumber === 0) {\n      return this.players[1];\n    } else {\n      return this.players[0];\n    }\n  }\n\n  /**\n   * Check if there is at least one valid move.\n   *\n   * If the head point or tail point of the path has any valid lines that can be formed to\n   * an adjacent point on the board, then there is a move available.\n   */\n  isMoveAvailable() {\n    const endPoints = [this.path.headPoint(), this.path.tailPoint()];\n    const lineValidator = new NewLineValidator(this.path);\n    for (const endPoint of endPoints) {\n      const adjacentPoints = this.getAdjacentPoints(endPoint);\n      for (const adjacentPoint of adjacentPoints) {\n        const line = new LineSegment(endPoint, adjacentPoint);\n        if (lineValidator.isValid(line)) {\n          DotGameLog.debug('Valid move available: ' + line.name);\n          return true;\n        }\n      }\n    }\n    DotGameLog.debug('No move is available!');\n    return false;\n  }\n\n  /**\n   * Get the adjacent points on the board\n   *\n   * @param point\n   */\n  getAdjacentPoints(point: Point): Point[] {\n    const points: Point[] = [];\n    for (let x = -1; x <= 1; x++) {\n      for (let y = -1; y <= 1; y++) {\n        const p = new Point(point.x + x, point.y + y);\n        if (this.isPointOnBoard(p) && !point.is(p)) {\n          points.push(p);\n        }\n      }\n    }\n    return points;\n  }\n\n  /**\n   * Game request handler\n   *\n   * @param messageJSON\n   */\n  request(messageJSON: any) {\n    DotGameLog.debug(messageJSON);\n\n    // Send a message when the player takes too long to perform an action\n    this.timeoutMessage();\n\n    const message = JSON.parse(messageJSON);\n    switch (message.msg) {\n      case 'NODE_CLICKED':\n        const point = new Point(message.body.x, message.body.y);\n        this.send(this._gameState.selectPoint(point));\n        break;\n      case 'ERROR':\n        const outMsg = 'What would you like me to do about it? Refresh if you got a problem.';\n        this.send(GameMessage.UpdateText(this.currentPlayer().name, outMsg));\n    }\n  }\n\n  /**\n   * Respond to the client\n   *\n   * @param message\n   */\n  send(message: GameMessage) {\n    DotGameLog.debug(message);\n    this.out(message);\n  }\n}\n","export enum GameMessageType {\n  // outputs\n  Initialize = 'INITIALIZE',\n  UpdateText = 'UPDATE_TEXT',\n  ValidStartNode = 'VALID_START_NODE',\n  InvalidStartNode = 'INVALID_START_NODE',\n  ValidEndNode = 'VALID_END_NODE',\n  InvalidEndNode = 'INVALID_END_NODE',\n  GameOver = 'GAME_OVER',\n  // inputs\n  NodeClicked = 'NODE_CLICKED',\n  Error = 'ERROR',\n}\n","import { LineSegment } from './line-segment';\nimport { Point } from './point';\n\nexport class LineOutput {\n  public readonly start: Point;\n  public readonly end: Point;\n\n  constructor(line: LineSegment) {\n    this.start = line.startPoint;\n    this.end = line.endPoint;\n  }\n}\n","import { LineSegment } from '../entities/line-segment';\nimport { Point } from '../entities/point';\nimport { InvalidLineTypeException } from '../exceptions/invalid-line-type.exception';\nimport { LineType } from '../validators/line.type';\nimport { Geometry } from './geometry';\n\n/**\n * Iterates (walks the line) over the integer points of the line.\n */\nexport class LineWalker {\n  /**\n   * Johnny Cash - I Walk the Line\n   * ---------------------------------------------\n   * I keep a close watch on this heart of mine\n   * I keep my eyes wide open all the time\n   * I keep the ends out for the tie that binds\n   * Because you're mine, I walk the line\n   *\n   * I find it very, very easy to be true\n   * I find myself alone when each day's through\n   * Yes, I'll admit that I'm a fool for you\n   * Because you're mine, I walk the line\n   *\n   * As sure as night is dark and day is light\n   * I keep you on my mind both day and night\n   * And happiness I've known proves that it's right\n   * Because you're mine, I walk the line\n   *\n   * You've got a way to keep me on your side\n   * You give me cause for love that I can't hide\n   * For you I know I'd even try to turn the tide\n   * Because you're mine, I walk the line\n   *\n   * I keep a close watch on this heart of mine\n   * I keep my eyes wide open all the time\n   * I keep the ends out for the tie that binds\n   * Because you're mine, I walk the line\n   *\n   * https://www.youtube.com/watch?v=jh169rVMveA\n   */\n\n  /**\n   *\n   * @param line\n   */\n  static walkTheLine(line: LineSegment): IterableIterator<Point> {\n    const lineType = Geometry.lineType(line);\n    switch (lineType) {\n      case LineType.Horizontal:\n        return LineWalker.doWalkHorizontal(line);\n      case LineType.Vertical:\n        return LineWalker.doWalkVertical(line);\n      // return LineWalker.walkNonDiagonal(line, lineType);\n      case LineType.Diagonal:\n        return LineWalker.walkDiagonal(line);\n      case LineType.Invalid:\n        throw new InvalidLineTypeException('Cannot walk an invalid line');\n    }\n  }\n\n  private static *walkDiagonal(line: LineSegment): IterableIterator<Point> {\n    const pointA = line.startPoint;\n    const pointB = line.endPoint;\n\n    const leftX = pointA.x;\n    const rightX = pointB.x;\n    const xDirection: number = rightX < leftX ? -1 : 1; // left vs right\n    const yDirection: number = pointB.y < pointA.y ? -1 : 1; // up vs down\n\n    // Amount of distance to travel\n    const distanceToTravel = Math.abs(leftX - rightX);\n\n    for (let i = 0; i <= distanceToTravel; i++) {\n      const x = pointA.x + xDirection * i;\n      const y = pointA.y + yDirection * i;\n      yield new Point(x, y);\n    }\n  }\n\n  private static *doWalkHorizontal(line: LineSegment): IterableIterator<Point> {\n    const pointA = line.startPoint;\n    const pointB = line.endPoint;\n\n    // Walk the points along the X-axis\n    const yAxis = pointA.y;\n    const beginX = pointA.x;\n    const endX = pointB.x;\n    const diff = Math.abs(endX - beginX);\n    const direction = beginX < endX ? 1 : -1;\n    for (let i = 0; i <= diff; i++) {\n      const x = beginX + i * direction;\n      yield new Point(x, yAxis);\n    }\n  }\n\n  private static *doWalkVertical(line: LineSegment): IterableIterator<Point> {\n    const pointA = line.startPoint;\n    const pointB = line.endPoint;\n    // Walk the points along the X-axis\n    const xAxis = pointA.x;\n    const beginY = pointA.y;\n    const endY = pointB.y;\n    const diff = Math.abs(endY - beginY);\n    const direction = beginY < endY ? 1 : -1;\n    for (let i = 0; i <= diff; i++) {\n      const y = beginY + i * direction;\n      yield new Point(xAxis, y);\n    }\n  }\n}\n","export class InvalidLineTypeException extends Error {\n  constructor(message?: string) {\n    super(message);\n    // see: typescriptlang.org/.doc/handbook/release-notes/typescript-2-2.html\n    Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain\n    this.name = InvalidLineTypeException.name; // stack traces display correctly now\n  }\n}\n","export class ParallelLinesException extends Error {\n  constructor(message?: string) {\n    super(message);\n    // see: typescriptlang.org/.doc/handbook/release-notes/typescript-2-2.html\n    Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain\n    this.name = ParallelLinesException.name; // stack traces display correctly now\n  }\n}\n","export class Player {\n  constructor(public readonly name: string) {}\n}\n","import { DotGameEngine } from '../dot-game.engine';\nimport { GameMessage } from '../entities/game-message';\nimport { Point } from '../entities/point';\nimport { DotGameState } from './dot-game.state';\n\n/**\n * Handles the state of the game when the game is over\n */\nexport class GameOverState implements DotGameState {\n  constructor(private readonly dotGame: DotGameEngine) {}\n\n  selectPoint(point: Point): GameMessage {\n    const heading = this.heading();\n    const message = 'Refresh to play again.';\n    return GameMessage.UpdateText(heading, message);\n  }\n\n  timeout(): GameMessage {\n    const heading = this.heading();\n    return GameMessage.UpdateText(heading, \"Refresh to play again. I'm waiting!\");\n  }\n\n  private heading() {\n    return `This Game is Over - ${this.dotGame.currentPlayer().name} Won!`;\n  }\n}\n","import { DotGameEngine } from '../dot-game.engine';\nimport { GameMessage } from '../entities/game-message';\n\nimport { LineSegment } from '../entities/line-segment';\nimport { Point } from '../entities/point';\nimport { NewLineValidator } from '../validators/new-line.validator';\nimport { DotGameState } from './dot-game.state';\n\n/**\n * Handles the state of the game when a ending point of a line is to be selected\n *\n * After the point is selected, the game checks if the game can proceed.\n */\nexport class LineEndState implements DotGameState {\n  constructor(private dotGame: DotGameEngine) {}\n\n  /**\n   *\n   * @param point\n   */\n  selectPoint(point: Point): GameMessage {\n    const line = new LineSegment(this.dotGame.startLinePoint, point);\n    const lineValidator = new NewLineValidator(this.dotGame.path);\n    const currentPlayerName = this.dotGame.currentPlayer().name;\n\n    if (point.is(this.dotGame.startLinePoint) || !lineValidator.isValid(line)) {\n      this.dotGame.gameState = this.dotGame.lineStartState;\n      return GameMessage.InvalidEndNode(currentPlayerName);\n    }\n\n    this.dotGame.path.addLine(line);\n\n    /*\n     * -----------------\n     * Game Ending Rules\n     * -----------------\n     * The game ends when no valid lines can be drawn.\n     * The player who draws the last line is the loser. (Making the other player the winner)\n     */\n\n    // Change players - It's either the next players move, or the next player wins.\n    this.dotGame.changePlayersTurn();\n    const nextPlayerName = this.dotGame.currentPlayer().name;\n\n    /*\n     * If there are still moves available, it becomes the next player turn to start a new line.\n     * Otherwise, it's Game Over!\n     */\n    if (this.dotGame.isMoveAvailable()) {\n      // Reset the state of the game to Line Start State\n      this.dotGame.gameState = this.dotGame.lineStartState;\n      return GameMessage.ValidEndNode(nextPlayerName, '', line);\n    } else {\n      // Game Over\n      this.dotGame.gameState = this.dotGame.gameOverState;\n      this.dotGame.clearTimoutMessage();\n      const heading = nextPlayerName + ' Wins!';\n      const message = `Sorry ${currentPlayerName}, you lost! Refresh to play again.`;\n      return GameMessage.GameOver(heading, message, line);\n    }\n  }\n\n  timeout(): GameMessage {\n    const message = \"Finish that line...if it's not too much trouble!\";\n    return GameMessage.UpdateText(this.dotGame.currentPlayer().name, message);\n  }\n}\n","import { LineSegment } from '../entities/line-segment';\nimport { Geometry } from '../geometry/geometry';\nimport { LineType } from './line.type';\n\nexport class OctilinearLineValidator {\n  /**\n   * Check if a line is horizontal, vertical or 45-degrees\n   *\n   * @param line\n   */\n  isValid(line: LineSegment) {\n    return Geometry.lineType(line) !== LineType.Invalid;\n  }\n}\n","import { DotGameLog } from '../dot-game.log';\nimport { LineSegment } from '../entities/line-segment';\nimport { PathTracker } from '../path-tracker';\n\n/**\n * Validates if the line segment\n */\nexport class VisitedNodeValidator {\n  constructor(private path: PathTracker) {}\n\n  /**\n   * Checks whether a NEW line does not visit another already visited node on the path;\n   * other than its own starting point.\n   *\n   * @param line\n   */\n  isNewLineValid(line: LineSegment) {\n    const linePoints = line.points();\n    for (const linePoint of linePoints) {\n      // Skip starting point\n      if (line.startPoint.is(linePoint)) {\n        continue;\n      }\n      for (const point of this.path.visitedPoints) {\n        if (linePoint.is(point)) {\n          DotGameLog.info(line.name + 'touches visited ' + point);\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n}\n","import { DotGameEngine } from '../dot-game.engine';\nimport { GameMessage } from '../entities/game-message';\nimport { Point } from '../entities/point';\nimport { DotGameState } from './dot-game.state';\n\n/**\n * Handles the state of the game when a starting point of a line is to be selected\n */\nexport class LineStartState implements DotGameState {\n  constructor(private dotGame: DotGameEngine) {}\n\n  selectPoint(point: Point): GameMessage {\n    const currentPlayerName = this.dotGame.currentPlayer().name;\n\n    if (!this.dotGame.isPointOnBoard(point)) {\n      const message = `${point.name} is not a valid dot on the board!`;\n      return GameMessage.InvalidStartNode(currentPlayerName, message);\n    }\n\n    /**\n     * A valid start Point is determined by whether if the Point is on the board, and\n     * if it is an endpoint of the path when there are endpoints available.\n     */\n    const isValidStartPoint =\n      this.dotGame.isPointOnBoard(point) &&\n      (!this.dotGame.path.hasEndPoints() || this.dotGame.path.isEndPoint(point));\n\n    if (isValidStartPoint) {\n      this.dotGame.gameState = this.dotGame.nextLineEndState;\n      this.dotGame.startLinePoint = point;\n      return GameMessage.ValidStartNode(currentPlayerName, '');\n    } else {\n      return GameMessage.InvalidStartNode(currentPlayerName);\n    }\n  }\n\n  timeout(): GameMessage {\n    const message = \"Let's get the show on the road. Start a new line at any time.\";\n    return GameMessage.UpdateText(this.dotGame.currentPlayer().name, message);\n  }\n}\n","import { DotGameLog } from './dot-game.log';\nimport { LineSegment } from './entities/line-segment';\nimport { Point } from './entities/point';\nimport { NoEndpointsException } from './exceptions/no-endpoints.exception';\n\n/**\n * Keeps track of the lines played and points visited during the game\n */\nexport class PathTracker {\n  private _visitedPoints: Point[] = [];\n  get visitedPoints() {\n    return this._visitedPoints;\n  }\n\n  // The lines that make up the path\n  private _lines: LineSegment[] = [];\n\n  /**\n   * The path as a series of points\n   */\n  get path() {\n    const path: Point[] = [];\n    let line: LineSegment | undefined;\n    for (line of this._lines) {\n      path.push(line.startPoint);\n    }\n    if (line) {\n      path.push(line.endPoint);\n    }\n    return path;\n  }\n\n  /**\n   * Get the lines that are constructed by extracting the from the path\n   */\n  get lines(): LineSegment[] {\n    return this._lines;\n  }\n\n  /**\n   * Store a new LineSegment\n   *\n   * If this is a continuation of the path, then prepend/append the line segments endpoint.\n   * Otherwise (i.e. no path yet), then all the lines points to the Path\n   *\n   * @param line\n   */\n  addLine(line: LineSegment) {\n    DotGameLog.debug('Adding Line: ', line.name);\n    DotGameLog.debug('Current Path:', this.path.toString());\n    // There IS an existing path!\n    if (this.hasEndPoints()) {\n      /**\n       * If the player used the head of the path prepend the points to the path; otherwise, append.\n       */\n      if (line.startPoint.is(this.headPoint())) {\n        // Flip the line as it's endpoint becomes that new head point of the path\n        const flippedLine = line.asFlipped();\n        DotGameLog.debug('Prepend Line(flipped): ', flippedLine.name);\n        this._lines.unshift(flippedLine);\n      } else {\n        DotGameLog.debug('Append Line: ', line.name);\n        this._lines.push(line);\n      }\n    } else {\n      // There IS NOT an existing path!\n      this._lines.push(line);\n    }\n\n    // Log the points that the lines visits\n    line.points().forEach(p => this._visitedPoints.push(p));\n\n    DotGameLog.debug('New Path:', this.path.toString());\n  }\n\n  /**\n   * Checks if there is a path at least 2 points\n   */\n  hasEndPoints() {\n    return this._lines.length > 0;\n    // return this._path.length > 1;\n  }\n\n  /**\n   * Check whether a path is an endpoint (beginning or end of the path).\n   *\n   * @param point\n   */\n  isEndPoint(point: Point) {\n    return this.headPoint().is(point) || this.tailPoint().is(point);\n  }\n\n  /**\n   * Get the Head (first) point on the path\n   */\n  headPoint() {\n    if (!this.hasEndPoints()) {\n      throw new NoEndpointsException('Head point does not exists');\n    }\n\n    return this._lines[0].startPoint;\n    // return this._path[0];\n  }\n\n  /**\n   * Get the Tail (last) point on the path\n   */\n  tailPoint() {\n    if (!this.hasEndPoints()) {\n      throw new NoEndpointsException('Tail point does not exists');\n    }\n    return this._lines[this.lines.length - 1].endPoint;\n    // return this._path[this._path.length - 1];\n  }\n\n  /**\n   * Build a path from a series of coordinate pairs\n   *\n   * @param coordinates Coordinate pairs\n   */\n  build(coordinates: number[][]) {\n    // this._path = []; // clear the path ... coming through\n    this._lines = [];\n    for (let i = 0; i < coordinates.length - 1; i++) {\n      const startPoint = new Point(coordinates[i][0], coordinates[i][1]);\n      const endPoint = new Point(coordinates[i + 1][0], coordinates[i + 1][1]);\n      this.addLine(new LineSegment(startPoint, endPoint));\n    }\n  }\n}\n","export class NoEndpointsException extends Error {\n  constructor(message?: string) {\n    super(message);\n    // see: typescriptlang.org/.doc/handbook/release-notes/typescript-2-2.html\n    Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain\n    this.name = NoEndpointsException.name; // stack traces display correctly now\n  }\n}\n"],"sourceRoot":""}