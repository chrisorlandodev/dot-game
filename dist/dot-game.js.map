{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///(webpack)/buildin/global.js","webpack:///./server/src/entities/game-message.ts-exposed","webpack:///./server/src/entities/point.ts-exposed","webpack:///./server/src/dot-game.log.ts-exposed","webpack:///./server/src/entities/line-segment.ts-exposed","webpack:///./server/src/geometry/line-type.ts-exposed","webpack:///./server/src/geometry/geometry.ts-exposed","webpack:///./server/src/validators/new-line.validator.ts-exposed","webpack:///./server/src/dot-game.ts-exposed","webpack:///./server/src/dot-game.ts","webpack:///./server/src/dot-game.engine.ts-exposed","webpack:///./server/src/dot-game.engine.ts","webpack:///./server/src/dot-game.log.ts","webpack:///./server/src/entities/game-message.ts","webpack:///./server/src/entities/game-message.type.ts-exposed","webpack:///./server/src/entities/game-message.type.ts","webpack:///./server/src/entities/line-output.ts-exposed","webpack:///./server/src/entities/line-output.ts","webpack:///./server/src/entities/line-segment.ts","webpack:///./server/src/geometry/line-walker.ts-exposed","webpack:///./server/src/geometry/line-walker.ts","webpack:///./server/src/entities/point.ts","webpack:///./server/src/exceptions/invalid-line-type.exception.ts-exposed","webpack:///./server/src/exceptions/invalid-line-type.exception.ts","webpack:///./server/src/geometry/line-type.ts","webpack:///./server/src/geometry/geometry.ts","webpack:///./server/src/exceptions/parallel-lines.exception.ts-exposed","webpack:///./server/src/exceptions/parallel-lines.exception.ts","webpack:///./server/src/entities/player.ts-exposed","webpack:///./server/src/entities/player.ts","webpack:///./server/src/game-states/game-over.state.ts-exposed","webpack:///./server/src/game-states/game-over.state.ts","webpack:///./server/src/game-states/line-end.state.ts-exposed","webpack:///./server/src/game-states/line-end.state.ts","webpack:///./server/src/validators/new-line.validator.ts","webpack:///./server/src/validators/octilinear-line.validator.ts-exposed","webpack:///./server/src/validators/octilinear-line.validator.ts","webpack:///./server/src/validators/visited-node.validator.ts-exposed","webpack:///./server/src/validators/visited-node.validator.ts","webpack:///./server/src/game-states/line-start.state.ts-exposed","webpack:///./server/src/game-states/line-start.state.ts","webpack:///./server/src/path-tracker.ts-exposed","webpack:///./server/src/path-tracker.ts","webpack:///./server/src/exceptions/no-endpoints.exception.ts-exposed","webpack:///./server/src/exceptions/no-endpoints.exception.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","g","this","Function","e","window","boardWidth","boardHeight","out","logger","game","DotGameEngine","initGame","request","messageJSON","init","Game","players","_path","PathTracker","_currentPlayerNumber","DotGameLog","setLogger","console","playerName","push","Player","lineStartState","LineStartState","nextLineEndState","LineEndState","gameOverState","GameOverState","_gameState","debug","state","constructor","changePlayersTurn","length","timeoutMessage","clearTimoutMessage","_timeoutMessage","setTimeout","send","timeout","clearTimeout","currentPlayer","GameMessage","Initialize","isPointOnBoard","point","x","y","waitingPlayer","isMoveAvailable","endPoints","path","headPoint","tailPoint","lineValidator","NewLineValidator","endPoint","adjacentPoints","getAdjacentPoints","adjacentPoint","line","LineSegment","isValid","points","Point","is","message","JSON","parse","msg","body","selectPoint","UpdateText","log","optionalParams","info","error","warn","heading","newLine","messageType","LineOutput","GameMessageType","ValidStartNode","InvalidStartNode","ValidEndNode","InvalidEndNode","GameOver","start","startPoint","end","_endPoint","_startPoint","toString","pointResult","iterator","LineWalker","walkTheLine","next","done","asFlipped","Geometry","lineType","LineType","Horizontal","doWalkHorizontal","Vertical","doWalkVertical","Diagonal","doWalkDiagonal","Invalid","InvalidLineTypeException","pointA","pointB","leftX","rightX","xDirection","yDirection","distanceToTravel","Math","abs","yAxis","beginX","endX","diff","direction","xAxis","beginY","endY","setPrototypeOf","Error","isBetween","check","temp","isPointOnLineSegment","checkPoint","isWithinXBounds","isWithinYBounds","areLinesParallel","line1","line2","findIntersectionOfLines","ParallelLinesException","doLineSegmentsTouch","intersectionPoint","intersectsOnLine1","intersectsOnLine2","s1","e1","s2","e2","a1","b1","c1","a2","b2","c2","delta","diffX","diffY","dotGame","startLinePoint","currentPlayerName","gameState","addLine","nextPlayerName","octilinearLineValidator","OctilinearLineValidator","visitedNodeValidator","VisitedNodeValidator","hasEndPoints","isEndPoint","isNewLineValid","totalTouchingLines","lines","checkLine","linePoints","linePoint","visitedPoints","_visitedPoints","_lines","flippedLine","unshift","forEach","NoEndpointsException","build","coordinates"],"mappings":"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","file":"dot-game.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","module.exports = global[\"DotGame\"] = require(\"-!G:\\\\dev\\\\dot-game\\\\node_modules\\\\ts-loader\\\\index.js!.\\\\game-message.ts\");","module.exports = global[\"DotGame\"] = require(\"-!G:\\\\dev\\\\dot-game\\\\node_modules\\\\ts-loader\\\\index.js!.\\\\point.ts\");","module.exports = global[\"DotGame\"] = require(\"-!G:\\\\dev\\\\dot-game\\\\node_modules\\\\ts-loader\\\\index.js!.\\\\dot-game.log.ts\");","module.exports = global[\"DotGame\"] = require(\"-!G:\\\\dev\\\\dot-game\\\\node_modules\\\\ts-loader\\\\index.js!.\\\\line-segment.ts\");","module.exports = global[\"DotGame\"] = require(\"-!G:\\\\dev\\\\dot-game\\\\node_modules\\\\ts-loader\\\\index.js!.\\\\line-type.ts\");","module.exports = global[\"DotGame\"] = require(\"-!G:\\\\dev\\\\dot-game\\\\node_modules\\\\ts-loader\\\\index.js!.\\\\geometry.ts\");","module.exports = global[\"DotGame\"] = require(\"-!G:\\\\dev\\\\dot-game\\\\node_modules\\\\ts-loader\\\\index.js!.\\\\new-line.validator.ts\");","module.exports = global[\"DotGame\"] = require(\"-!G:\\\\dev\\\\dot-game\\\\node_modules\\\\ts-loader\\\\index.js!.\\\\dot-game.ts\");","import { DotGameEngine } from './dot-game.engine';\nimport { DotGameLogInterface } from './dot-game.log';\n\n/**\n * DotGame\n *\n * Exposes a the DotGame's request handler and initializes the game engine\n */\nexport class Game {\n  private game: DotGameEngine;\n\n  constructor(\n    private boardWidth: number = 4,\n    private boardHeight: number = 4,\n    private out: any,\n    logger?: DotGameLogInterface\n  ) {\n    this.game = new DotGameEngine(boardWidth, boardHeight, out, logger);\n    this.game.initGame();\n  }\n\n  request(messageJSON: any) {\n    this.game.request(messageJSON);\n  }\n\n  init() {\n    this.game.initGame();\n  }\n}\n","module.exports = global[\"DotGame\"] = require(\"-!G:\\\\dev\\\\dot-game\\\\node_modules\\\\ts-loader\\\\index.js!.\\\\dot-game.engine.ts\");","import { DotGameLog, DotGameLogInterface } from './dot-game.log';\nimport { GameMessage } from './entities/game-message';\nimport { LineSegment } from './entities/line-segment';\nimport { Player } from './entities/player';\nimport { Point } from './entities/point';\nimport { DotGameState } from './game-states/dot-game.state';\nimport { GameOverState } from './game-states/game-over.state';\nimport { LineEndState } from './game-states/line-end.state';\nimport { LineStartState } from './game-states/line-start.state';\nimport { PathTracker } from './path-tracker';\nimport { NewLineValidator } from './validators/new-line.validator';\n\n/**\n * The game engine\n */\nexport class DotGameEngine {\n  public readonly lineStartState: DotGameState;\n  public readonly nextLineEndState: DotGameState;\n  public readonly gameOverState: DotGameState;\n\n  /**\n   * The Players of the game\n   */\n  private players: Player[] = [];\n\n  /**\n   * Path tracker\n   */\n  private _path: PathTracker = new PathTracker();\n\n  get path() {\n    return this._path;\n  }\n\n  /**\n   * Reference to the timeout message\n   */\n  private _timeoutMessage?: number | null;\n\n  /**\n   * Holds the state of the game\n   */\n  private _gameState: DotGameState;\n\n  /**\n   * Set the game set\n   *\n   * @param state\n   */\n  set gameState(state: DotGameState) {\n    DotGameLog.debug('Game State: ' + state.constructor.name);\n    this._gameState = state;\n  }\n\n  /**\n   * The current player's index number in the players array\n   */\n  private _currentPlayerNumber = 0; // Player 1 always starts\n\n  // Keeps track of the current players starting line Point\n  public startLinePoint!: Point;\n\n  /**\n   * Create a new DotGame\n   *\n   * @param boardWidth\n   * @param boardHeight\n   * @param out\n   * @param logger\n   */\n  constructor(\n    private boardWidth: number = 4,\n    private boardHeight: number = 4,\n    private out: any,\n    logger?: DotGameLogInterface\n  ) {\n    if (!logger) {\n      DotGameLog.setLogger(console);\n    }\n\n    // Create Players\n    for (let i = 0; i < 2; i++) {\n      const playerName = 'Player ' + (i + 1); // player 0\n      this.players.push(new Player(playerName));\n    }\n\n    this.lineStartState = new LineStartState(this);\n    this.nextLineEndState = new LineEndState(this);\n    this.gameOverState = new GameOverState(this);\n    this._gameState = this.lineStartState;\n\n    DotGameLog.debug('');\n    DotGameLog.debug('-------------------');\n    DotGameLog.debug('DotGame constructed');\n    DotGameLog.debug('-------------------');\n  }\n\n  /**\n   * Change the player's turns\n   */\n  public changePlayersTurn() {\n    this._currentPlayerNumber++;\n    if (this._currentPlayerNumber === this.players.length) {\n      this._currentPlayerNumber = 0;\n    }\n  }\n\n  /**\n   * Send a message when the player takes too long to perform an action.\n   *\n   * Clears any existing timeout message prior to setting a new timeout message\n   */\n  public timeoutMessage() {\n    // Clear any timeout message that is waiting to be sent\n    this.clearTimoutMessage();\n    // Send a timeout message X secs after a node is selected\n    // @ts-ignore\n    this._timeoutMessage = setTimeout(() => {\n      this.send(this._gameState.timeout());\n    }, 5000);\n  }\n\n  /**\n   * Clear an existing timeout message if one exists\n   */\n  public clearTimoutMessage() {\n    if (this._timeoutMessage) {\n      clearTimeout(this._timeoutMessage);\n      this._timeoutMessage = null;\n    }\n  }\n\n  /**\n   * Initialize a new game by resetting the game state\n   */\n  initGame() {\n    this._gameState = this.lineStartState;\n    this._currentPlayerNumber = 0;\n    this._path = new PathTracker();\n    const playerName = this.currentPlayer().name;\n    this.timeoutMessage();\n    DotGameLog.debug('New Game Initialized');\n    this.send(GameMessage.Initialize(playerName, `Awaiting ${playerName}'s Move`));\n  }\n\n  /**\n   * Checks if a Point is on the board.\n   *\n   * @param point\n   */\n  isPointOnBoard(point: Point): boolean {\n    return point.x >= 0 && point.x < this.boardWidth && point.y >= 0 && point.y < this.boardHeight;\n  }\n\n  /**\n   * Gets the current Player\n   */\n  currentPlayer() {\n    return this.players[this._currentPlayerNumber];\n  }\n\n  /**\n   * Get the other player who is waiting for their turn\n   */\n  waitingPlayer() {\n    if (this._currentPlayerNumber === 0) {\n      return this.players[1];\n    } else {\n      return this.players[0];\n    }\n  }\n\n  /**\n   * Check if there is at least one valid move.\n   *\n   * If the head point or tail point of the path has any valid lines that can be formed to\n   * an adjacent point on the board, then there is a move available.\n   */\n  isMoveAvailable() {\n    const endPoints = [this.path.headPoint(), this.path.tailPoint()];\n    const lineValidator = new NewLineValidator(this.path);\n    for (const endPoint of endPoints) {\n      const adjacentPoints = this.getAdjacentPoints(endPoint);\n      for (const adjacentPoint of adjacentPoints) {\n        const line = new LineSegment(endPoint, adjacentPoint);\n        if (lineValidator.isValid(line)) {\n          DotGameLog.debug('Valid move available: ' + line.name);\n          return true;\n        }\n      }\n    }\n    DotGameLog.debug('No move is available!');\n    return false;\n  }\n\n  /**\n   * Get the adjacent points on the board\n   *\n   * @param point\n   */\n  getAdjacentPoints(point: Point): Point[] {\n    const points: Point[] = [];\n    for (let x = -1; x <= 1; x++) {\n      for (let y = -1; y <= 1; y++) {\n        const p = new Point(point.x + x, point.y + y);\n        if (this.isPointOnBoard(p) && !point.is(p)) {\n          points.push(p);\n        }\n      }\n    }\n    return points;\n  }\n\n  /**\n   * Game request handler\n   *\n   * @param messageJSON\n   */\n  request(messageJSON: any) {\n    DotGameLog.debug(messageJSON);\n\n    // Send a message when the player takes too long to perform an action\n    this.timeoutMessage();\n\n    const message = JSON.parse(messageJSON);\n    switch (message.msg) {\n      case 'INITIALIZE':\n        this.initGame();\n        break;\n      case 'NODE_CLICKED':\n        const point = new Point(message.body.x, message.body.y);\n        this.send(this._gameState.selectPoint(point));\n        break;\n      case 'ERROR':\n        const outMsg = 'What would you like me to do about it? Refresh if you got a problem.';\n        this.send(GameMessage.UpdateText(this.currentPlayer().name, outMsg));\n    }\n  }\n\n  /**\n   * Respond to the client\n   *\n   * @param message\n   */\n  send(message: GameMessage) {\n    DotGameLog.debug(message);\n    this.out(message);\n  }\n}\n","export interface DotGameLogInterface {\n  log(message: any, ...optionalParams: any[]): void;\n  info(message: any, ...optionalParams: any[]): void;\n  error(message: any, ...optionalParams: any[]): void;\n  warn(message: any, ...optionalParams: any[]): void;\n  debug(message: any, ...optionalParams: any[]): void;\n}\n\n/**\n * DotGame Logger\n */\nexport class DotGameLog {\n  private static logger: DotGameLogInterface = console;\n\n  static setLogger(logger: any) {\n    DotGameLog.logger = logger;\n  }\n\n  static log(message: any, ...optionalParams: any[]) {\n    DotGameLog.logger.log(message, ...optionalParams);\n  }\n\n  static info(message: any, ...optionalParams: any[]) {\n    DotGameLog.logger.info(message, ...optionalParams);\n  }\n\n  static error(message: any, ...optionalParams: any[]) {\n    DotGameLog.logger.error(message, ...optionalParams);\n  }\n\n  static warn(message: any, ...optionalParams: any[]) {\n    DotGameLog.logger.warn(message, ...optionalParams);\n  }\n\n  static debug(message: any, ...optionalParams: any[]) {\n    DotGameLog.logger.debug(message, ...optionalParams);\n  }\n}\n","import { GameMessageType } from './game-message.type';\nimport { LineOutput } from './line-output';\nimport { LineSegment } from './line-segment';\n\n/**\n * Game Message response\n */\nexport class GameMessage {\n  public readonly body: { newLine: null | LineOutput; heading: string; message: string };\n\n  private constructor(\n    public msg: string,\n    heading: string = '',\n    message: string = '',\n    newLine: LineOutput | null = null\n  ) {\n    this.msg = msg;\n    this.body = { newLine, heading, message };\n  }\n\n  /**\n   *\n   * @param messageType\n   * @param heading\n   * @param message\n   * @param line\n   * @constructor\n   */\n  private static create(\n    messageType: string,\n    heading: string,\n    message: string,\n    line?: LineSegment\n  ): GameMessage {\n    const newLine = line ? new LineOutput(line) : null;\n    return new GameMessage(messageType, heading, message, newLine);\n  }\n\n  /////////////////////////////////////////////////////\n  // Static methods to safely create game messages\n  ////////////////////////////////////////////////////\n\n  /**\n   * Create an INITIALIZE game message\n   *\n   * @param heading\n   * @param message\n   */\n  static Initialize(heading: string, message: string) {\n    return GameMessage.create(GameMessageType.Initialize, heading, message);\n  }\n\n  /**\n   * Create a VALID_START_NODE game message\n   *\n   * @param heading\n   * @param message\n   */\n  static ValidStartNode(heading: string, message: string) {\n    return GameMessage.create(GameMessageType.ValidStartNode, heading, message);\n  }\n\n  /**\n   * Create an INVALID_START_NODE game message\n   *\n   * @param heading\n   * @param message\n   */\n  static InvalidStartNode(\n    heading: string,\n    message: string = 'You must start on either end of the path!'\n  ) {\n    return GameMessage.create(GameMessageType.InvalidStartNode, heading, message);\n  }\n\n  /**\n   * Create a VALID_END_NODE game message\n   *\n   * @param heading\n   * @param message\n   * @param newLine\n   */\n  static ValidEndNode(heading: string, message: string, newLine: LineSegment): GameMessage {\n    return GameMessage.create(GameMessageType.ValidEndNode, heading, message, newLine);\n  }\n\n  /**\n   * Create an INVALID_END_NODE game message\n   *\n   * @param heading\n   * @param message\n   */\n  static InvalidEndNode(heading: string, message: string = 'Not a valid line.') {\n    return GameMessage.create(GameMessageType.InvalidEndNode, heading, message);\n  }\n\n  /**\n   * Create a GAME_OVER game message\n   *\n   * @param heading\n   * @param message\n   * @param newLine\n   */\n  static GameOver(heading: string, message: string, newLine: LineSegment): GameMessage {\n    return GameMessage.create(GameMessageType.GameOver, heading, message, newLine);\n  }\n\n  /**\n   * Create a GAME_OVER game message\n   *\n   * @param heading\n   * @param message\n   */\n  static UpdateText(heading: string, message: string): GameMessage {\n    return GameMessage.create(GameMessageType.UpdateText, heading, message);\n  }\n}\n","module.exports = global[\"DotGame\"] = require(\"-!G:\\\\dev\\\\dot-game\\\\node_modules\\\\ts-loader\\\\index.js!.\\\\game-message.type.ts\");","export enum GameMessageType {\n  // outputs\n  Initialize = 'INITIALIZE',\n  UpdateText = 'UPDATE_TEXT',\n  ValidStartNode = 'VALID_START_NODE',\n  InvalidStartNode = 'INVALID_START_NODE',\n  ValidEndNode = 'VALID_END_NODE',\n  InvalidEndNode = 'INVALID_END_NODE',\n  GameOver = 'GAME_OVER',\n  // inputs\n  NodeClicked = 'NODE_CLICKED',\n  Error = 'ERROR',\n}\n","module.exports = global[\"DotGame\"] = require(\"-!G:\\\\dev\\\\dot-game\\\\node_modules\\\\ts-loader\\\\index.js!.\\\\line-output.ts\");","import { LineSegment } from './line-segment';\nimport { Point } from './point';\n\nexport class LineOutput {\n  public readonly start: Point;\n  public readonly end: Point;\n\n  constructor(line: LineSegment) {\n    this.start = line.startPoint;\n    this.end = line.endPoint;\n  }\n}\n","import { LineWalker } from '../geometry/line-walker';\nimport { Point } from './point';\n\nexport class LineSegment {\n  private readonly _startPoint: Point;\n  get startPoint() {\n    return this._startPoint;\n  }\n\n  private readonly _endPoint: Point;\n\n  get endPoint() {\n    return this._endPoint;\n  }\n\n  constructor(startPoint: Point, endPoint: Point) {\n    this._endPoint = endPoint;\n    this._startPoint = startPoint;\n  }\n\n  // Accessors\n\n  get name() {\n    return `${this._startPoint.name}-${this._endPoint.name},`;\n  }\n\n  toString() {\n    return 'Line of ' + this.name;\n  }\n\n  /**\n   * Get the points that this line visits\n   */\n  points() {\n    const points: Point[] = [];\n    const iterator = LineWalker.walkTheLine(this);\n    let pointResult: IteratorResult<Point>;\n\n    while (true) {\n      pointResult = iterator.next();\n      if (pointResult.done) {\n        break;\n      }\n      points.push(pointResult.value);\n    }\n    return points;\n  }\n\n  /**\n   * Get a new reversed line by swapping the endpoints\n   */\n  asFlipped() {\n    return new LineSegment(this.endPoint, this.startPoint);\n  }\n}\n","module.exports = global[\"DotGame\"] = require(\"-!G:\\\\dev\\\\dot-game\\\\node_modules\\\\ts-loader\\\\index.js!.\\\\line-walker.ts\");","import { LineSegment } from '../entities/line-segment';\nimport { Point } from '../entities/point';\nimport { InvalidLineTypeException } from '../exceptions/invalid-line-type.exception';\nimport { LineType } from './line-type';\nimport { Geometry } from './geometry';\n\n/**\n * Iterates (walks the line) over the integer points of the line.\n */\nexport class LineWalker {\n  /**\n   * Johnny Cash - I Walk the Line\n   * ---------------------------------------------\n   * I keep a close watch on this heart of mine\n   * I keep my eyes wide open all the time\n   * I keep the ends out for the tie that binds\n   * Because you're mine, I walk the line\n   *\n   * I find it very, very easy to be true\n   * I find myself alone when each day's through\n   * Yes, I'll admit that I'm a fool for you\n   * Because you're mine, I walk the line\n   *\n   * As sure as night is dark and day is light\n   * I keep you on my mind both day and night\n   * And happiness I've known proves that it's right\n   * Because you're mine, I walk the line\n   *\n   * You've got a way to keep me on your side\n   * You give me cause for love that I can't hide\n   * For you I know I'd even try to turn the tide\n   * Because you're mine, I walk the line\n   *\n   * I keep a close watch on this heart of mine\n   * I keep my eyes wide open all the time\n   * I keep the ends out for the tie that binds\n   * Because you're mine, I walk the line\n   *\n   * https://www.youtube.com/watch?v=jh169rVMveA\n   */\n\n  /**\n   *\n   * @param line\n   */\n  static walkTheLine(line: LineSegment): IterableIterator<Point> {\n    const lineType = Geometry.lineType(line);\n    switch (lineType) {\n      case LineType.Horizontal:\n        return LineWalker.doWalkHorizontal(line);\n      case LineType.Vertical:\n        return LineWalker.doWalkVertical(line);\n      case LineType.Diagonal:\n        return LineWalker.doWalkDiagonal(line);\n      case LineType.Invalid:\n        throw new InvalidLineTypeException('Cannot walk an invalid line');\n    }\n  }\n\n  private static *doWalkDiagonal(line: LineSegment): IterableIterator<Point> {\n    const pointA = line.startPoint;\n    const pointB = line.endPoint;\n\n    const leftX = pointA.x;\n    const rightX = pointB.x;\n    const xDirection: number = rightX < leftX ? -1 : 1; // left vs right\n    const yDirection: number = pointB.y < pointA.y ? -1 : 1; // up vs down\n\n    // Amount of distance to travel\n    const distanceToTravel = Math.abs(leftX - rightX);\n\n    for (let i = 0; i <= distanceToTravel; i++) {\n      const x = pointA.x + xDirection * i;\n      const y = pointA.y + yDirection * i;\n      yield new Point(x, y);\n    }\n  }\n\n  private static *doWalkHorizontal(line: LineSegment): IterableIterator<Point> {\n    const pointA = line.startPoint;\n    const pointB = line.endPoint;\n\n    // Walk the points along the X-axis\n    const yAxis = pointA.y;\n    const beginX = pointA.x;\n    const endX = pointB.x;\n    const diff = Math.abs(endX - beginX);\n    const direction = beginX < endX ? 1 : -1;\n    for (let i = 0; i <= diff; i++) {\n      const x = beginX + i * direction;\n      yield new Point(x, yAxis);\n    }\n  }\n\n  private static *doWalkVertical(line: LineSegment): IterableIterator<Point> {\n    const pointA = line.startPoint;\n    const pointB = line.endPoint;\n    // Walk the points along the Y-axis\n    const xAxis = pointA.x;\n    const beginY = pointA.y;\n    const endY = pointB.y;\n    const diff = Math.abs(endY - beginY);\n    const direction = beginY < endY ? 1 : -1;\n    for (let i = 0; i <= diff; i++) {\n      const y = beginY + i * direction;\n      yield new Point(xAxis, y);\n    }\n  }\n}\n","export class Point {\n  constructor(public readonly x: number, public readonly y: number) {}\n\n  /**\n   * Check whether a given point is the same point;\n   *\n   * @param point\n   */\n  is(point: Point) {\n    return this.x === point.x && this.y === point.y;\n  }\n\n  get name() {\n    return `(${this.x},${this.y})`;\n  }\n\n  toString() {\n    return 'Point' + this.name;\n  }\n}\n","module.exports = global[\"DotGame\"] = require(\"-!G:\\\\dev\\\\dot-game\\\\node_modules\\\\ts-loader\\\\index.js!.\\\\invalid-line-type.exception.ts\");","export class InvalidLineTypeException extends Error {\n  constructor(message?: string) {\n    super(message);\n    // see: typescriptlang.org/.doc/handbook/release-notes/typescript-2-2.html\n    Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain\n    this.name = InvalidLineTypeException.name; // stack traces display correctly now\n  }\n}\n","export enum LineType {\n  Horizontal,\n  Vertical,\n  Diagonal,\n  Invalid,\n}\n","import { LineSegment } from '../entities/line-segment';\nimport { Point } from '../entities/point';\nimport { ParallelLinesException } from '../exceptions/parallel-lines.exception';\nimport { LineType } from './line-type';\n\nexport class Geometry {\n  /**\n   * Determine if a value is between (inclusive) of two other values\n   *\n   * @param check\n   * @param start\n   * @param end\n   */\n  private static isBetween(check: number, start: number, end: number): boolean {\n    if (start > end) {\n      const temp = start;\n      start = end;\n      end = temp;\n    }\n    return start <= check && check <= end;\n  }\n\n  /**\n   * Check if a Point is on a Line Segment\n   *\n   * @param checkPoint\n   * @param line\n   */\n  static isPointOnLineSegment(checkPoint: Point, line: LineSegment): boolean {\n    const startPoint: Point = line.startPoint;\n    const endPoint: Point = line.endPoint;\n\n    if (checkPoint.is(startPoint) || checkPoint.is(endPoint)) {\n      return true;\n    }\n\n    const slopeOfStartCheck = (startPoint.x - checkPoint.x) / (startPoint.y - checkPoint.y);\n    const slopeOfCheckEnd = (checkPoint.x - endPoint.x) / (checkPoint.y - endPoint.y);\n\n    // If the slopes are different then the Check point is not on the infinite line\n    const isSameSlope = slopeOfStartCheck === slopeOfCheckEnd;\n    if (!isSameSlope) {\n      return false;\n    }\n\n    const isWithinXBounds = Geometry.isBetween(checkPoint.x, startPoint.x, endPoint.x);\n    const isWithinYBounds = Geometry.isBetween(checkPoint.y, startPoint.y, endPoint.y);\n    return isWithinXBounds && isWithinYBounds;\n  }\n\n  /**\n   * Checks if two line segments are parallel\n   *\n   * @param line1\n   * @param line2\n   */\n  static areLinesParallel(line1: LineSegment, line2: LineSegment) {\n    try {\n      // Throws ParallelLinesException is the lines are parallel\n      Geometry.findIntersectionOfLines(line1, line2);\n      return false;\n    } catch (e) {\n      if (e instanceof ParallelLinesException) {\n        // lines are parallel\n        return true;\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * Check whether two line segments touch with each other\n   *\n   * @param line1\n   * @param line2\n   */\n  static doLineSegmentsTouch(line1: LineSegment, line2: LineSegment): boolean {\n    try {\n      // If any endpoint is on the other line than they touch.\n      if (\n        Geometry.isPointOnLineSegment(line1.startPoint, line2) ||\n        Geometry.isPointOnLineSegment(line1.endPoint, line2) ||\n        Geometry.isPointOnLineSegment(line2.startPoint, line1) ||\n        Geometry.isPointOnLineSegment(line2.endPoint, line1)\n      ) {\n        return true;\n      }\n\n      const intersectionPoint = Geometry.findIntersectionOfLines(line1, line2);\n      const intersectsOnLine1 = Geometry.isPointOnLineSegment(intersectionPoint, line1);\n      const intersectsOnLine2 = Geometry.isPointOnLineSegment(intersectionPoint, line2);\n      return intersectsOnLine1 && intersectsOnLine2;\n    } catch (e) {\n      if (e instanceof ParallelLinesException) {\n        // lines are parallel\n        return false;\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * Find the intersection of two Line segments as if they were infinite lines\n   *\n   * Courtesy of https://rosettacode.org/wiki/Find_the_intersection_of_two_lines#C.23\n   *\n   * @param line1\n   * @param line2\n   * @throws ParallelLinesException\n   */\n  static findIntersectionOfLines(line1: LineSegment, line2: LineSegment): Point {\n    // Starting point of first line\n    const s1 = line1.startPoint;\n    // Ending point of first line\n    const e1 = line1.endPoint;\n    // Starting point of second line\n    const s2 = line2.startPoint;\n    // Ending point of second line\n    const e2 = line2.endPoint;\n\n    const a1 = e1.y - s1.y;\n    const b1 = s1.x - e1.x;\n    const c1 = a1 * s1.x + b1 * s1.y;\n\n    const a2 = e2.y - s2.y;\n    const b2 = s2.x - e2.x;\n    const c2 = a2 * s2.x + b2 * s2.y;\n\n    const delta = a1 * b2 - a2 * b1;\n    // When delta is 0 the lines are parallel.\n    if (delta === 0) {\n      throw new ParallelLinesException('Lines do not intersect!');\n    } else {\n      return new Point((b2 * c1 - b1 * c2) / delta, (a1 * c2 - a2 * c1) / delta);\n    }\n  }\n\n  /**\n   * Determines if the line segment is horizontal, vertical or diagonal (45-degrees)\n   *\n   * @param line\n   */\n  static lineType(line: LineSegment): LineType {\n    const startPoint = line.startPoint;\n    const endPoint = line.endPoint;\n\n    if (startPoint.x === endPoint.x && startPoint.y === endPoint.y) {\n      return LineType.Invalid;\n    }\n\n    const diffX = Math.abs(startPoint.x - endPoint.x);\n    const diffY = Math.abs(startPoint.y - endPoint.y);\n\n    // Is Vertical line\n    const isVerticalLine = diffX === 0 && diffY !== 0;\n    if (isVerticalLine) {\n      return LineType.Vertical;\n    }\n\n    // Horizontal line\n    const isHorizontalLine = diffY === 0 && diffX !== 0;\n    if (isHorizontalLine) {\n      return LineType.Horizontal;\n    }\n\n    // Diagonal line @ 45-degrees\n    const isDiagonal = diffX === diffY;\n    if (isDiagonal) {\n      return LineType.Diagonal;\n    }\n\n    // If it's not horizontal, vertical or at a 45-degree angle, it's invalid for this game.\n    return LineType.Invalid;\n  }\n}\n","module.exports = global[\"DotGame\"] = require(\"-!G:\\\\dev\\\\dot-game\\\\node_modules\\\\ts-loader\\\\index.js!.\\\\parallel-lines.exception.ts\");","export class ParallelLinesException extends Error {\n  constructor(message?: string) {\n    super(message);\n    // see: typescriptlang.org/.doc/handbook/release-notes/typescript-2-2.html\n    Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain\n    this.name = ParallelLinesException.name; // stack traces display correctly now\n  }\n}\n","module.exports = global[\"DotGame\"] = require(\"-!G:\\\\dev\\\\dot-game\\\\node_modules\\\\ts-loader\\\\index.js!.\\\\player.ts\");","export class Player {\n  constructor(public readonly name: string) {}\n}\n","module.exports = global[\"DotGame\"] = require(\"-!G:\\\\dev\\\\dot-game\\\\node_modules\\\\ts-loader\\\\index.js!.\\\\game-over.state.ts\");","import { DotGameEngine } from '../dot-game.engine';\nimport { GameMessage } from '../entities/game-message';\nimport { Point } from '../entities/point';\nimport { DotGameState } from './dot-game.state';\n\n/**\n * Handles the state of the game when the game is over\n */\nexport class GameOverState implements DotGameState {\n  constructor(private readonly dotGame: DotGameEngine) {}\n\n  selectPoint(point: Point): GameMessage {\n    const heading = this.heading();\n    const message = 'Refresh to play again.';\n    return GameMessage.UpdateText(heading, message);\n  }\n\n  timeout(): GameMessage {\n    const heading = this.heading();\n    return GameMessage.UpdateText(heading, \"Refresh to play again. I'm waiting!\");\n  }\n\n  private heading() {\n    return `This Game is Over - ${this.dotGame.currentPlayer().name} Won!`;\n  }\n}\n","module.exports = global[\"DotGame\"] = require(\"-!G:\\\\dev\\\\dot-game\\\\node_modules\\\\ts-loader\\\\index.js!.\\\\line-end.state.ts\");","import { DotGameEngine } from '../dot-game.engine';\nimport { GameMessage } from '../entities/game-message';\n\nimport { LineSegment } from '../entities/line-segment';\nimport { Point } from '../entities/point';\nimport { NewLineValidator } from '../validators/new-line.validator';\nimport { DotGameState } from './dot-game.state';\n\n/**\n * Handles the state of the game when a ending point of a line is to be selected\n *\n * After a line is played, the game checks if the game can proceed.\n */\nexport class LineEndState implements DotGameState {\n  constructor(private dotGame: DotGameEngine) {}\n\n  /**\n   *\n   * @param point\n   */\n  selectPoint(point: Point): GameMessage {\n    const line = new LineSegment(this.dotGame.startLinePoint, point);\n    const lineValidator = new NewLineValidator(this.dotGame.path);\n    const currentPlayerName = this.dotGame.currentPlayer().name;\n\n    if (point.is(this.dotGame.startLinePoint) || !lineValidator.isValid(line)) {\n      this.dotGame.gameState = this.dotGame.lineStartState;\n      return GameMessage.InvalidEndNode(currentPlayerName);\n    }\n\n    this.dotGame.path.addLine(line);\n\n    /*\n     * -----------------\n     * Game Ending Rules\n     * -----------------\n     * The game ends when no valid lines can be drawn.\n     * The player who draws the last line is the loser. (Making the other player the winner)\n     */\n\n    // Change players - It's either the next players move, or the next player wins.\n    this.dotGame.changePlayersTurn();\n    const nextPlayerName = this.dotGame.currentPlayer().name;\n\n    /*\n     * If there are still moves available, it becomes the next player's turn to start a new line.\n     * Otherwise, it's Game Over!\n     */\n    if (this.dotGame.isMoveAvailable()) {\n      // Reset the state of the game to Line Start State\n      this.dotGame.gameState = this.dotGame.lineStartState;\n      return GameMessage.ValidEndNode(nextPlayerName, '', line);\n    } else {\n      // Game Over\n      this.dotGame.gameState = this.dotGame.gameOverState;\n      this.dotGame.clearTimoutMessage();\n      const heading = nextPlayerName + ' Wins!';\n      const message = `Sorry ${currentPlayerName}, you lost! Refresh to play again.`;\n      return GameMessage.GameOver(heading, message, line);\n    }\n  }\n\n  timeout(): GameMessage {\n    const message = \"Finish that line...if it's not too much trouble!\";\n    return GameMessage.UpdateText(this.dotGame.currentPlayer().name, message);\n  }\n}\n","import { DotGameLog } from '../dot-game.log';\nimport { LineSegment } from '../entities/line-segment';\nimport { Geometry } from '../geometry/geometry';\nimport { PathTracker } from '../path-tracker';\nimport { OctilinearLineValidator } from './octilinear-line.validator';\nimport { VisitedNodeValidator } from './visited-node.validator';\n\n/**\n * Validates if a new line is a valid line\n *\n * A new line:\n * - Must be an Octilinear line\n * - AND If a path exists:\n *    - Must start at the head or tail of the path (i.e. endpoints of the path)\n *    - AND Cannot visit another visited node (other than it's starting point)\n *    - AND May not touch another line touch other than the line it was continued from\n *           - can't intersect (i.e.: can't touch more than one line)\n */\nexport class NewLineValidator {\n  private readonly octilinearLineValidator: OctilinearLineValidator;\n  private readonly visitedNodeValidator: VisitedNodeValidator;\n\n  constructor(private readonly path: PathTracker) {\n    this.octilinearLineValidator = new OctilinearLineValidator();\n    this.visitedNodeValidator = new VisitedNodeValidator(path);\n  }\n\n  isValid(line: LineSegment) {\n    // - Must be an Octilinear line\n    if (!this.octilinearLineValidator.isValid(line)) {\n      return false;\n    }\n\n    // - If a path exists\n    if (this.path.hasEndPoints()) {\n      // - Must start at the head or tail of the path\n      if (!this.path.isEndPoint(line.startPoint)) {\n        return false;\n      }\n\n      // - May not touch another line touch\n\n      if (!this.visitedNodeValidator.isNewLineValid(line)) {\n        return false;\n      }\n\n      // It's implied that the new line is touching a point on the path by the check above\n\n      let totalTouchingLines = 0;\n      for (const checkLine of this.path.lines) {\n        if (Geometry.doLineSegmentsTouch(line, checkLine)) {\n          totalTouchingLines++;\n          // The 1 line would be the from the continuation of the path\n          if (totalTouchingLines > 1) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n}\n","module.exports = global[\"DotGame\"] = require(\"-!G:\\\\dev\\\\dot-game\\\\node_modules\\\\ts-loader\\\\index.js!.\\\\octilinear-line.validator.ts\");","import { LineSegment } from '../entities/line-segment';\nimport { Geometry } from '../geometry/geometry';\nimport { LineType } from '../geometry/line-type';\n\nexport class OctilinearLineValidator {\n  /**\n   * Check if a line is horizontal, vertical or 45-degrees\n   *\n   * @param line\n   */\n  isValid(line: LineSegment) {\n    return Geometry.lineType(line) !== LineType.Invalid;\n  }\n}\n","module.exports = global[\"DotGame\"] = require(\"-!G:\\\\dev\\\\dot-game\\\\node_modules\\\\ts-loader\\\\index.js!.\\\\visited-node.validator.ts\");","import { DotGameLog } from '../dot-game.log';\nimport { LineSegment } from '../entities/line-segment';\nimport { PathTracker } from '../path-tracker';\n\n/**\n * Validates if the line segment\n */\nexport class VisitedNodeValidator {\n  constructor(private path: PathTracker) {}\n\n  /**\n   * Checks whether a NEW line does not visit another already visited node on the path;\n   * other than its own starting point.\n   *\n   * @param line\n   */\n  isNewLineValid(line: LineSegment) {\n    const linePoints = line.points();\n    for (const linePoint of linePoints) {\n      // Skip starting point\n      if (line.startPoint.is(linePoint)) {\n        continue;\n      }\n      for (const point of this.path.visitedPoints) {\n        if (linePoint.is(point)) {\n          DotGameLog.info(line.name + 'touches visited ' + point);\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n}\n","module.exports = global[\"DotGame\"] = require(\"-!G:\\\\dev\\\\dot-game\\\\node_modules\\\\ts-loader\\\\index.js!.\\\\line-start.state.ts\");","import { DotGameEngine } from '../dot-game.engine';\nimport { GameMessage } from '../entities/game-message';\nimport { Point } from '../entities/point';\nimport { DotGameState } from './dot-game.state';\n\n/**\n * Handles the state of the game when a starting point of a line is to be selected\n */\nexport class LineStartState implements DotGameState {\n  constructor(private dotGame: DotGameEngine) {}\n\n  selectPoint(point: Point): GameMessage {\n    const currentPlayerName = this.dotGame.currentPlayer().name;\n\n    if (!this.dotGame.isPointOnBoard(point)) {\n      const message = `${point.name} is not a valid dot on the board!`;\n      return GameMessage.InvalidStartNode(currentPlayerName, message);\n    }\n\n    /**\n     * A valid start Point is determined by whether if the Point is on the board, and\n     * if it is an endpoint of the path when there are endpoints available.\n     */\n    const isValidStartPoint =\n      this.dotGame.isPointOnBoard(point) &&\n      (!this.dotGame.path.hasEndPoints() || this.dotGame.path.isEndPoint(point));\n\n    if (isValidStartPoint) {\n      this.dotGame.gameState = this.dotGame.nextLineEndState;\n      this.dotGame.startLinePoint = point;\n      return GameMessage.ValidStartNode(currentPlayerName, '');\n    } else {\n      return GameMessage.InvalidStartNode(currentPlayerName);\n    }\n  }\n\n  timeout(): GameMessage {\n    const message = \"Let's get the show on the road. Start a new line at any time.\";\n    return GameMessage.UpdateText(this.dotGame.currentPlayer().name, message);\n  }\n}\n","module.exports = global[\"DotGame\"] = require(\"-!G:\\\\dev\\\\dot-game\\\\node_modules\\\\ts-loader\\\\index.js!.\\\\path-tracker.ts\");","import { DotGameLog } from './dot-game.log';\nimport { LineSegment } from './entities/line-segment';\nimport { Point } from './entities/point';\nimport { NoEndpointsException } from './exceptions/no-endpoints.exception';\n\n/**\n * Keeps track of the lines played and points visited during the game\n */\nexport class PathTracker {\n  private _visitedPoints: Point[] = [];\n  get visitedPoints() {\n    return this._visitedPoints;\n  }\n\n  // The lines that make up the path\n  private _lines: LineSegment[] = [];\n\n  /**\n   * The path as a series of points\n   */\n  get path() {\n    const path: Point[] = [];\n    let line: LineSegment | undefined;\n    for (line of this._lines) {\n      path.push(line.startPoint);\n    }\n    if (line) {\n      path.push(line.endPoint);\n    }\n    return path;\n  }\n\n  /**\n   * Get the lines that are constructed by extracting the from the path\n   */\n  get lines(): LineSegment[] {\n    return this._lines;\n  }\n\n  /**\n   * Store a new LineSegment\n   *\n   * If this is a continuation of the path, then prepend/append the line segments endpoint.\n   * Otherwise (i.e. no path yet), then all the lines points to the Path\n   *\n   * @param line\n   */\n  addLine(line: LineSegment) {\n    DotGameLog.debug('Adding Line: ', line.name);\n    DotGameLog.debug('Current Path:', this.path.toString());\n    // There IS an existing path!\n    if (this.hasEndPoints()) {\n      /**\n       * If the player used the head of the path prepend the points to the path; otherwise, append.\n       */\n      if (line.startPoint.is(this.headPoint())) {\n        // Flip the line as it's endpoint becomes the new head point of the path\n        const flippedLine = line.asFlipped();\n        DotGameLog.debug('Prepend Line(flipped): ', flippedLine.name);\n        this._lines.unshift(flippedLine);\n      } else {\n        DotGameLog.debug('Append Line: ', line.name);\n        this._lines.push(line);\n      }\n    } else {\n      // There IS NOT an existing path!\n      this._lines.push(line);\n    }\n\n    // Log the points that the lines visits\n    line.points().forEach(p => this._visitedPoints.push(p));\n\n    DotGameLog.debug('New Path:', this.path.toString());\n  }\n\n  /**\n   * Checks if there is a path at least 2 points\n   */\n  hasEndPoints() {\n    return this._lines.length > 0;\n  }\n\n  /**\n   * Check whether a path is an endpoint (beginning or end of the path).\n   *\n   * @param point\n   */\n  isEndPoint(point: Point) {\n    return this.headPoint().is(point) || this.tailPoint().is(point);\n  }\n\n  /**\n   * Get the Head (first) point on the path\n   */\n  headPoint() {\n    if (!this.hasEndPoints()) {\n      throw new NoEndpointsException('Head point does not exists');\n    }\n\n    return this._lines[0].startPoint;\n  }\n\n  /**\n   * Get the Tail (last) point on the path\n   */\n  tailPoint() {\n    if (!this.hasEndPoints()) {\n      throw new NoEndpointsException('Tail point does not exists');\n    }\n    return this._lines[this.lines.length - 1].endPoint;\n  }\n\n  /**\n   * Build a path from a series of coordinate pairs\n   *\n   * @param coordinates Coordinate pairs\n   */\n  build(coordinates: number[][]) {\n    this._lines = [];\n    for (let i = 0; i < coordinates.length - 1; i++) {\n      const startPoint = new Point(coordinates[i][0], coordinates[i][1]);\n      const endPoint = new Point(coordinates[i + 1][0], coordinates[i + 1][1]);\n      this.addLine(new LineSegment(startPoint, endPoint));\n    }\n  }\n}\n","module.exports = global[\"DotGame\"] = require(\"-!G:\\\\dev\\\\dot-game\\\\node_modules\\\\ts-loader\\\\index.js!.\\\\no-endpoints.exception.ts\");","export class NoEndpointsException extends Error {\n  constructor(message?: string) {\n    super(message);\n    // see: typescriptlang.org/.doc/handbook/release-notes/typescript-2-2.html\n    Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain\n    this.name = NoEndpointsException.name; // stack traces display correctly now\n  }\n}\n"],"sourceRoot":""}